# message queue

### 示例
一个标准的披萨饼店，你可以发现有人会获取订单，在做披萨饼的过程中，披萨饼店是不会停止从新的客户获取订单的。很多个客户请求披萨订单，它获取到的反馈，比如，“稍等，请坐”，或者，“你可以待会儿再过来”。这里，你给客户一个及时的响应，不是直接给披萨饼，而是，一个说明，订单将会被处理的确认。所以，现在你需要的仅仅是一个列表，列表记录按顺序的订单。

当你有了这样一个列表，你就可以，记录下订单，然后，开始做披萨饼。当另一个客户过来时，你要做的仅仅是记录下订单，将它排在做披萨饼的队列里。PO1,PO2,PO3,...在你做这一个披萨饼的同时，你可以获取任意多，你想要的订单。当你做好一个披萨饼时，你就可以从队列里删除这个披萨，从列表里移除这项记录，这时你可以要求客户支付订单。


### 异步操作
这里，所有的操作都是异步的，你不需要客户端一直在等你做好披萨饼的响应，再去支付披萨饼。在你做披萨饼的同时，你会允许客户做任何他想做的事情，比如，接听个电话，等等。你允许客户，将资源分配给其他的事项，而不是关注于你。这也给披萨的制作者，带来了好处。比如，你可以根据任务的优先级，重新调整做披萨饼的顺序，也有一些其他简单的事情可以做，比如，填补平底锅。队列里的订单，可以根据优先级进行调整。利用异步操作，披萨制作者，和客户都可以更明智的分配时间。


### 数据持久化
一个很好的情况是，你变得特别成功，你有很多连锁店，你的店有很多销路，像多米诺骨牌。例如，分店1，分店2，分店3，等等，每个店都有很好的销路。现在其中一家店停电了，到店的这些顾客，我们必然需要放弃。然而，分配给这家店的外卖顾客，我也需要放弃吗？显然，可以不放弃。这时，订单列表我们不应该存放在内存里，因为内存中的数据是断电易失。我们应该有一个数据库来，存放当前所有的数据。

### 订单重新分配
数据库中表包含三个字段，（订单id，订单内容，订单是否完成），当一个店出错的时候，最直接的方式，就是从数据库中，将该店所有未完成订单分配给其他的店。这里就需要再家一个字段，该店的来源。常规的做法，是有一个Notifier(通知者)，监听各家店的(Heart Beat)心跳，每隔一段时间，查询一下机器是否还活着，将所有剩余订单发送给所有活着的机器，这就需要，某一个订单只能分配给一个机器，不然，会有两家店做同一个订单，这就需要用到之前负载均衡相关的知识，这里的通知者，就是message queue或者task queue，它会封装这一切的功能。这是对服务器端复杂度很好的封装，比较著名的消息队列有，RABBIT MQ，Zero MQ，JMS。