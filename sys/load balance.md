# consistent hash (一致性哈希)
## Load Balance
与hash有关，但是一致性hash有一些特殊的性质。这些性质是做大系统和可扩展系统所必需的。你的服务越做越大，原本你在一台服务器上的服务，现在你有新增了一台机器，你应该把服务的请求发给哪台机器呢？比如，你现在有n台机器，你想要去均衡这些请求的负载。因为，每个请求都需要机器去处理，所以，每台机器都有负载。如何平衡这些负载，这被称为负载均衡。一致性hash把我们完成这些。

你可以得到每个请求的请求id，你可以认为，请求id是均匀分布的，是一个随机的0 - M-1的一个数，这个请求id，也会被发给你的服务器。你的服务器可以对这个id进行hash，hash(id)->m%n，hash结果可以映射到一台机器上。请求id是均匀随机的，hash函数也是均匀随机的，你可以认为每台机器的负载也是均衡的。

## 迁移的开销

当你业务做大，新增机器时，这时hash的模数需要增大，n->n+1。我们来看看这种方法的迁移开销，比如，原先n为4，现在n为5。（25%，25%，25%，25%）-> (20%, 20%, 20%, 20%, 20%) 迁移开销(5%),(5%,10%)(10%,15%),(15%,20%),(20%)，这样，迁移开销一共就是100%，这里会有什么问题呢？

如果，可以一个用户的请求都发送到同一台机器，这时，你就可以在本地进行缓存，提高效率。但这种hash规则，每次会重新打散用户。一种比较好的方式，就是从每个机器，分散出一些请求。这些分出的请求之和就是20%。但是，整体的修改在这种情况下是最少的。

## 环上的hash

这需要做的就是一致性hash。我们的目标就是将request ID 映射到一个0~M-1的值，M现在并不代表服务器的大小，比服务器大很多。这里的hash，像一个环。在模运算中，m-1与0实际是相连的。每个请求都分配到环上的一个区间。我们对机器也进行hash，机器也会映射到环上的一个点，当请求过来时，它通过hash，找到自己在环上的位置，然后，在顺时针找到最近的一台服务器。这个服务器来响应对应的请求。对服务器进行hash，你可以假设，服务器之间的距离是均匀的。所以，负载是均衡的。

新增一台机器，只是在环上新增一个点，只会影响到一台服务器的请求。有一台机器失效，也只会影响一台机器的请求。这种环状的hash，可能会造成某些节点过载。

## 虚拟服务
运用多个hash函数，这样，每个服务器在环上有多个节点，这时，负载会均衡的概率会大大提高。运用K个hash函数，这个K可以设为log(M)

