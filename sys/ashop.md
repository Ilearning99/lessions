# A Shop Example

### 假设你有一家披萨店，你如何经营好它

- 一开始，假设你只有一位厨师，现在无法满足所有订单，该怎么做？
  
  最简单地，你希望这个厨师，更加努力工作，你可以给这位厨师更多的钱。对于系统来说，你想要优化进程，在相同资源的情况下，提高进程的吞吐。这就是vertical scaling。谈到优化进程，你可以提前做很多事情。就像做披萨，很多东西，你并不需要等订单到了，你再做。比如，你可以把面在不忙的时候先和好。在没有订单的时候，你可以做很多事情。
  
- 可恢复性 (resilient)

  假设你的厨师生病了，请了一天病假，你的生意这一天就黄了，因为你只有一个厨师，这就是single point of failure。 这时你的解决办法就是有一个备用的厨师，当前厨师生病的时候，你可以雇佣备用厨师。keep backups and avoid single points of failure.在计算机领域，这就是master/slave结构，主从结构。当你的生意越做越大，会将备用厨师雇用为全职厨师，事实上，你应该雇用更多的厨师。假设，你现在有更多的全职厨师，和一部分备用厨师。这对应horizontal scaling。horizontal scaling就是买更多相似的机器，让处理更多的事情变成可能。
  
  
- 微服务 (micro service)

  假设现在我们有三个厨师，他们各有一些专长。1和3号厨师，擅长做披萨，2号厨师擅长做咖喱。如果，你有两个订单，分别是一份披萨和一份咖喱，你应该如何分配他们。一种简单的办法是随机分配订单，比如，让1号厨师做咖喱，2号厨师做披萨，但这种分配方式效率不高，你没有用到你的员工的长处，你应该让1和3号厨师接受所有披萨订单，让2号厨师做所有咖喱订单。这样，问题就简单了，任何和咖喱相关的就找厨师2，和披萨相关的就找厨师1和3。比如，咖喱的订单少，你就安排3个厨师，披萨订单人多你就安排7个厨师。你将7个厨师分成两组，一组3人，一组4人。这样，我们给每个team划分了职责，这种就可以称为微服务架构。你将这些职责都明确定义了之后，这样，在你职责之外的事，你就不用处理了。这样所有人都有专长，扩展也很方便。
  
  
- 分布式系统

  如果披萨店停电了怎么办？当停电或你的商店吊销执照了，你也什么都干不了。你所要做的就是分布式，我的意思是，你不要把鸡蛋都放在一个篮子里，所以，你应该再买一个分店，在另一个位置，也能够配送披萨。及时配送时间更长，你有更少的厨师，但是，至少你有一个备份。当你有个新的店，你的程序会复杂到一个新的层次。因为，现在你需要在商店之间做通讯。你需要能够去路由你的请求。例如，你有一个订单，我应该把这个订单分配给哪一个店呢？一个比较简单的分配方式，我们总是将距离店更近的订单分配给它。像Facebook这样的分布式系统，你需要很多本地服务器。一个分布式系统，我们就会有更多的容错，和更快的响应。
  
- 负载均衡(load balance)
  
  假设你有两个旧商店，有一个配送代理。你有客户，每当客户有请求时，这个请求可以被发送个第一家店或者第二家店，但客户并不管这些，所以，你应该把请求送给某个中间人。中间位置，可以路由请求。你不想随机的发送请求。你有一个明确的参数，用户得到披萨饼需要多长时间。将请求发给一号店，这可能是一家非常热门的门店，可能需要1小时，在队列里等待。5分钟做饼，10分钟去运输，一共需要1h15m，将请求发给二号店，15+10+40，有更少的等待时间，所以只需要1h5分钟。所以，中间人应该把订单发送给第二家店。中间人可以根据实时的信息，做出智能的决策将订单发送给哪家店。意味着可以挣更多的钱。这种智能的路由方式，被称作负载均衡。
  
- Decoupling
  
  现在系统是具有容错性的，如何能让系统能够灵活的修改，以经得住未来的考验呢？目前，我们至少应该让配送代理，和披萨店没有什么相同的部分。这里是说，对于配送代理，这里的店可以是披萨店，也可以是汉堡店。配送代理，只想尽快配送他的货物到客户。类似的，披萨店不会去管配送代理，客户同样也不会管。这里，我们发现了职责分开，而不是一个经理，管所有的事情。我们希望系统的职责分开，这被称作decouple系统，分离关注点，这样，你可以更有效的分离系统。
  
- logging and metrics

  假设现在第一家店，有一台烤箱坏了，它的搅拌效率下降了，配送中心有一辆自行车坏了，配送中心的配送时长上升了。这时，你想要记录所有的事情，这样，你可以看到在不同时刻发生了什么。你可以拿到这些信息，考虑它们，从中找到一些想法。
  
  - Analytics
  - Auditing
  - Reporting
  - Machine Learning
  
  最后也是最重要的一点，作为一个后端工程师，你要保证你系统的可扩展性，你不希望一遍又一遍的重写这些代码来实习其他的功能。配送中心不知道店里正在做披萨饼，它也可能明天做汉堡，你看亚马逊，它早期是只送包裹，你能够去扩展你的生意，是因为你想要拆解所有的事情，来确保你的系统是可扩展的。我们所做的事情是考虑一个场景，试图去解决它会遇到的所有问题。然后将它们与技术属于相映射。你可以认为上面这些方案本身是解决类似技术问题的方法。最终，我们可以扩展我们的餐厅。现在，我们可以定义我们遇到的问题，以及我们的解决方案。这种抽象是更高层的设计，对应的实际的决绝方案，我们称为底层设计。让我们简单讨论一下。
  
- high level vs. low level
  
  高层抽象是我们会在这个系列课程中讲的。例如，在服务器上部署服务。理解系统怎样进行交互，知道越多的系统设计，会让你了解更多如何编写代码，比如，设计类，设计对象，函数，声明，如果你是一个高级工程师，这对你来说，非常重要。虽然，你不是，如果你想成为senior工程师，你应该知道如何写高效，干净的代码。面向对象系统设计的面试，就是从需求，到代码，到清晰的UML设计。
  